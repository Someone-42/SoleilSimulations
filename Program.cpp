#include <cmath>
#include <locale>
#include <memory>
#include <stdint.h>
#define OLC_PGE_APPLICATION
#include "olcPixelGameEngine.h"

using namespace olc;
using namespace std;

uint64_t GetTimems()
{
  return chrono::duration_cast<chrono::milliseconds>(chrono::system_clock::now().time_since_epoch()).count();
}

class Box
{
public:
  vf2d pos;
  vf2d size;

  bool BoxCollision(Box& other)
  {
    bool hitx = pos.x + size.x >= other.pos.x && other.pos.x + other.size.x >= pos.x;
    bool hity = pos.y + size.y >= other.pos.y && other.pos.y + other.size.y >= pos.y;
    return hitx && hity;
  }

  bool PointCollision(vf2d& point)
  {
    return point.x >= pos.x && point.x <= pos.x + size.x && point.y >= pos.y && point.y <= point.y + size.y;
  }
};

class Simulation
{
protected:
  // Time since epoch captured upon call of Start()
  uint64_t startTime;
  // Time in ms since simulation was started
  uint32_t timeElapsed;

public:
  PixelGameEngine* engine;
  // Sprite* view = nullptr;
  // Decal* viewDecal = nullptr;
  vf2d viewPos;
  vf2d viewSize;

  Simulation(PixelGameEngine* engine)
  {
    this->engine = engine;
  }

  void UpdateView(vf2d viewPos, vi2d viewSize)
  {
    this->viewPos = viewPos;
    this->viewSize = viewSize;
  }

  virtual void Reset();

  // Called to create and start the simulation
  virtual void Start()
  {
    startTime = GetTimems();
  }

  virtual void Update(float deltaTime)
  {
    timeElapsed = GetTimems() - timeElapsed;
  }

  virtual void Render();
};

class Component : public Box
{
public:
  Simulation* simulation;

  Pixel color;

  Component(Simulation* simulation)
  {
    this->simulation = simulation;
  }

  Component(Simulation* simulation, vi2d pos, vi2d size)
  {
    this->simulation = simulation;
    this->pos = pos;
    this->size = size;
  }

  virtual void Draw()
  {
    simulation->engine->FillRectDecal(simulation->viewPos + pos, size, color);
  }
};

class CopperPipe : public Component
{

public:
  CopperPipe(Simulation* simulation) : Component(simulation)
  {
  }

  Pixel innerColor;
  void Draw() override
  {
    vf2d sz = vf2d(size.x / 2, size.y);
    simulation->engine->GradientFillRectDecal(simulation->viewPos + pos, sz, color, color, innerColor, innerColor);
    simulation->engine->GradientFillRectDecal(simulation->viewPos + pos + vf2d(size.x / 2, 0), sz, innerColor,
                                              innerColor, color, color);
  }
};

class Graph : public Component
{
public:
  Sprite buffer;
  Decal* decal = nullptr;

  Graph(Simulation* simulation) : Component(simulation)
  {
  }

  ~Graph()
  {
    cout << "Called delete on graph" << endl;
    delete decal;
  }

  Pixel clearColor = Pixel(0, 0, 0);
  Pixel outlineColor = Pixel(100, 100, 100);

  void Set(vector<vf2d> points)
  {
    buffer.SetSize(size.x, size.y);
    vf2d minp = points[0];
    vf2d maxp = points[points.size() - 1];
    // Extract min and max for y
    for (vf2d point : points)
    {
      if (point.y > maxp.y)
        maxp.y = point.y;
      if (point.y < minp.y)
        minp.y = point.y;
    }

    // Affine transformation to map points on the graph
    vf2d a = size / (maxp - minp);
    vf2d b = -minp * a;

    // Draw on buffer
    simulation->engine->SetDrawTarget(&buffer);
    simulation->engine->Clear(clearColor);

    for (int i = 0; i < points.size() - 1; i++)
    {
      vi2d X = a * points[i] + b;
      vi2d Y = a * points[i + 1] + b;
      // cout << X << " : " << Y << endl;
      simulation->engine->DrawLine(X, Y, color);
    }

    simulation->engine->SetDrawTarget(nullptr);

    delete decal;
    decal = new Decal(&buffer);
  }

  // running is a float between 0 and 1
  //  It represents the amount of the graph curve that should be shown
  void Draw(float running)
  {
    // simulation->engine->DrawSprite(pos, &buffer);
    simulation->engine->DrawPartialDecal(pos, decal, {0, 0}, {size.x * running, size.y});
    simulation->engine->DrawRectDecal(pos, size + vf2d(1, 1), outlineColor);
  }
};

class MagnetSimulation : public Simulation
{
public:
  Pixel color;

  Component pipePVC = Component(this);
  CopperPipe pipeCopper = CopperPipe(this);

  const float g = 9.81;
  const float oppForce = 0.8; // Opposition generated by magnetic field relative to velocity
  float timeScale = 12;

  Component magnet = Component(this);
  float magnetSpeed = 0;
  vf2d magnetStartPos[2];
  char magnetCurrentPos = 0;

  unique_ptr<Graph> magnetGraphPVC;
  unique_ptr<Graph> magnetGraphCopper;
  vector<vf2d> speedMagnetPVC;
  vector<vf2d> speedMagnetCopper;

  MagnetSimulation(PixelGameEngine* engine, Pixel color) : Simulation(engine)
  {
    this->color = color;
    magnet.color = Pixel(165, 165, 165);
    pipeCopper.color = Pixel(184, 115, 51);
    pipeCopper.innerColor = Pixel(150, 50, 20);
    pipePVC.color = Pixel(128, 128, 160);
    magnetGraphPVC = unique_ptr<Graph>(new Graph(this));
    magnetGraphCopper = unique_ptr<Graph>(new Graph(this));

    magnetGraphPVC->color = Pixel(0, 255, 255);
    magnetGraphPVC->clearColor = Pixel(0, 0, 0);
    magnetGraphPVC->outlineColor = pipePVC.color;

    magnetGraphCopper->color = Pixel(0, 255, 255);
    magnetGraphCopper->clearColor = Pixel(0, 0, 0);
    magnetGraphCopper->outlineColor = pipeCopper.color;

    // TODO: Generate points
  }

  ~MagnetSimulation()
  {
  }

  void Reset() override
  {
    // -------------------
    // | Placing objects |
    // -------------------

    // Resize components accordingly
    // Half of the screen is taken by the pipes
    vf2d vs = viewSize * vf2d(0.5, 1);
    cout << vs << endl;
    int x = vs.y / 10;

    pipePVC.size = vi2d(1.5 * x, vs.y * 0.7);
    pipePVC.pos = vi2d(vs.x / 4, vs.y * 0.6) - pipePVC.size / 2;

    pipeCopper.size = vi2d(1.5 * x, vs.y * 0.7);
    pipeCopper.pos = vi2d(3 * vs.x / 4, vs.y * 0.6) - pipeCopper.size / 2;

    magnet.size = vi2d(1 * x, x / 3);
    magnet.pos = vi2d(pipePVC.pos.x + pipePVC.size.x / 2, vs.y * 0.05) - (magnet.size / 2);

    magnetStartPos[0] = magnet.pos;
    magnetStartPos[1] = magnet.pos + (vf2d(1, 0) * (-pipePVC.pos.x + pipeCopper.pos.x));

    // Place graphs with a little padding
    vf2d padding = viewSize / 42;
    vf2d graphSize = viewSize / 2 - (2 * padding); // quarter minus padding
    magnetGraphPVC->pos = vf2d(vs.x, 0) + padding; // Positionned after pipes
    magnetGraphPVC->size = graphSize;

    magnetGraphCopper->pos = vf2d(vs.x, viewSize.y / 2) + padding; // Positionned after pipes
    magnetGraphCopper->size = graphSize;

    // ----------
    // | Graphs |
    // ----------

    // Simulate simulation - Graph points

    uint64_t _time = GetTimems();
    speedMagnetPVC.clear();
    speedMagnetCopper.clear();

    speedMagnetPVC.push_back(vf2d(0, 0));
    speedMagnetCopper.push_back(vf2d(0, 0));

    float pos = 0;
    float timeStep = 0.01;

    int i = 1;
    while (pos <= viewSize.y)
    {
      speedMagnetPVC.push_back(vf2d(pos, 0));

      // multiplying both velocities by -1 so the graph is drawn in the correct way (not reversed)
      speedMagnetPVC[i].y = -((-speedMagnetPVC[i - 1].y) + g * timeStep);
      pos -= speedMagnetPVC[i].y * timeStep;

      i++;
    }
    cout << "Resolution for graph 1 is : " << i << " points" << endl;

    pos = 0;
    timeStep = 0.02;

    i = 1;
    while (pos <= viewSize.y)
    {
      speedMagnetCopper.push_back(vf2d(pos, 0));

      float acc = g;
      // If the magnet is inside the copper pipe
      if (pos >= pipeCopper.pos.y && pos <= pipeCopper.pos.y + pipeCopper.size.y)
        acc += oppForce * speedMagnetCopper[i - 1].y;

      // multiplying both velocities by -1 so the graph is drawn in the correct way (not reversed)
      speedMagnetCopper[i].y = -((-speedMagnetCopper[i - 1].y) + acc * timeStep);
      pos -= speedMagnetCopper[i].y * timeStep;
      i++;
    }
    cout << "Resolution for graph 2 is : " << i << " points" << endl;
    cout << "Generation took : " << GetTimems() - _time << endl;

    magnetGraphPVC->Set(speedMagnetPVC);
    magnetGraphCopper->Set(speedMagnetCopper);
    cout << "Total took : " << GetTimems() - _time << endl;
  }

  void Start() override
  {
    Simulation::Start();

    magnetSpeed = 0;
    magnetCurrentPos = 0;
    magnet.pos = magnetStartPos[magnetCurrentPos];
  }

  void ChangeMagnetPipe()
  {
    magnetSpeed = 0;
    magnetCurrentPos = 1 - magnetCurrentPos;
    magnet.pos = magnetStartPos[magnetCurrentPos];
  }

  void Update(float deltaTime) override
  {
    Simulation::Update(deltaTime);

    deltaTime *= timeScale;

    float acc = g;

    if (magnet.BoxCollision(pipeCopper))
    {
      // This is a lorentz force simulation
      // At some velocity, the induced magnetic field, creates opposing force equal to gravity
      // therefore the accelerations returns to 0
      //
      // And the magnet should move at constant speeds
      //
      // Therefore we multiply by some kind of simulation constant
      acc -= 0.8 * magnetSpeed;
    }

    magnetSpeed += deltaTime * acc;

    magnet.pos.y += magnetSpeed * deltaTime;

    if (magnet.pos.y >= viewSize.y)
      ChangeMagnetPipe();
  }

  void Render() override
  {
    engine->FillRectDecal(viewPos, viewSize, color);

    pipePVC.Draw();
    pipeCopper.Draw();
    magnet.Draw();

    float adv[2] = {1, 1};
    adv[magnetCurrentPos] = magnet.pos.y / viewSize.y;
    magnetGraphPVC->Draw(adv[0]);
    magnetGraphCopper->Draw(adv[1]);
  }
};

class Balloon
{
public:
  Balloon(Simulation* simulation)
  {
    this->simulation = simulation;
  }

  Simulation* simulation;

  vf2d pos;
  float radius;

  Pixel color;

  void Draw()
  {
    simulation->engine->DrawCircle(pos + simulation->viewPos, radius, color);
  }
};

class VacuumSimulation : public Simulation
{
public:
  Pixel color;

  Component container = Component(this);
  Balloon balloon = Balloon(this);

  VacuumSimulation(PixelGameEngine* engine, Pixel color) : Simulation(engine)
  {
    this->color = color;
  }

  void Reset() override
  {
    vf2d v = viewSize / 12;
    container.pos = v;
    container.size = viewSize - 2 * v;

    balloon.pos = viewSize / 2;
    balloon.radius = 100;

    balloon.color = Pixel(255, 0, 255);
    container.color = Pixel(150, 150, 150);
  }

  void Start() override
  {
    Simulation::Start();
  }

  void Update(float deltaTime) override
  {
    Simulation::Update(deltaTime);
  }

  void Render() override
  {
    // engine->FillRectDecal(viewPos, viewSize, color);

    // container.Draw();
    balloon.Draw();
  }
};

// TODO: Finish implementing
class Text : public Box
{
private:
  vf2d scale;
  vf2d centerPos;
  string content;

public:
  string getText()
  {
    return content;
  }

  void setText(string text)
  {
    content = text;
  }

  void DrawDecal()
  {
  }
};

class Button : public Box
{
public:
  Pixel bgColor;
  Pixel accentColor;
  Pixel hoverColor;
  Pixel clickColor;

  // TODO: Add text

  bool mouseOn;

  PixelGameEngine* engine;

  void Draw()
  {
    Pixel col;
    if (mouseOn)
    {
      if (engine->GetMouse(0).bPressed)
      {
        col = clickColor;
      }
      else
      {
        col = hoverColor;
      }
    }

    engine->FillRectDecal(pos, size, col);
    engine->DrawRectDecal(pos, size, accentColor);
  }
};

class SimulationWindow : public olc::PixelGameEngine
{
private:
  vector<unique_ptr<Simulation>> simulations;
  int currentSimulation = 0;

  Pixel clearColor = Pixel(0, 0, 0);

public:
  SimulationWindow()
  {
    simulations.emplace_back(new MagnetSimulation(this, Pixel(0, 0, 0)));
    // simulations.emplace_back(new VacuumSimulation(this, Pixel(0, 0, 0)));
  }

  ~SimulationWindow()
  {
  }

public:
  void SwapSimulation()
  {
    currentSimulation = (currentSimulation + 1) % simulations.size();
    simulations[currentSimulation]->Start();
  }

  bool OnUserCreate() override
  {
    simulations[0]->UpdateView(vi2d(0, 0), vi2d(ScreenWidth(), ScreenHeight()));
    simulations[1]->UpdateView(vi2d(0, 0), vi2d(ScreenWidth(), ScreenHeight()));
    for (auto& simulation : simulations)
    {
      simulation->Reset();
      simulation->Start();
    }

    return true;
  }

  bool OnUserUpdate(float fElapsedTime) override
  {
    // ---------------------
    //      Update Cycle
    // ---------------------
    simulations[currentSimulation]->Update(fElapsedTime);

    // ---------------------
    //      Render Cycle
    // ---------------------
    // SetDrawTarget(simulation->view);
    simulations[currentSimulation]->Render();
    // DrawDecal(simulation->viewPos, simulation->viewDecal);

    // Going back to main screen for rendering

    // TODO: Draw delimiter ? UI ?
    return true;
  }
};

int main()
{
  SimulationWindow window;
  if (window.Construct(1920 >> 1, 1080 >> 1, 2, 2, true))
    window.Start();

  return 0;
}

// TODO: Add button to swap pane
// TODO: Add vacuum simulation with balloon
